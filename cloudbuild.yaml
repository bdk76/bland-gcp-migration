# Cloud Build configuration for Bland GCP Migration
# This file is triggered automatically when code is pushed to the connected GitHub repository

# Substitution variables (can be overridden in trigger configuration)
substitutions:
  _PROJECT_ID: bland-gcp-migration
  _REGION: us-central1
  _SERVICE_NAME: bland-api
  _ARTIFACT_REGISTRY: us-central1-docker.pkg.dev/bland-gcp-migration/bland-images
  _NODE_VERSION: '20'
  _DEPLOY_TIMEOUT: '600s'

# Build configuration options
options:
  # Use machine type with more resources for faster builds
  machineType: 'E2_HIGHCPU_8'
  
  # Increase disk size for large builds
  diskSizeGb: 100
  
  # Use kaniko for better layer caching
  substitutionOption: 'ALLOW_LOOSE'
  
  # Log streaming to Cloud Logging
  logging: CLOUD_LOGGING_ONLY
  
  # Dynamic substitutions based on branch
  dynamicSubstitutions: true

# Build timeout (default is 10 minutes, increase for complex builds)
timeout: 1800s

# Build steps
steps:
  # Step 1: Install dependencies and run tests
  - name: 'node:${_NODE_VERSION}'
    id: 'install-and-test'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "ðŸ“¦ Installing dependencies..."
        npm ci
        
        echo "ðŸ” Running linter..."
        npm run lint || echo "No lint script found"
        
        echo "ðŸ§ª Running tests..."
        npm test || echo "No test script found"
        
        echo "ðŸ”’ Running security audit..."
        npm audit --audit-level=moderate || true
    waitFor: ['-']

  # Step 2: Build Docker image using Kaniko for better caching
  - name: 'gcr.io/kaniko-project/executor:latest'
    id: 'build-image'
    args:
      - '--destination=${_ARTIFACT_REGISTRY}/${_SERVICE_NAME}:${COMMIT_SHA}'
      - '--destination=${_ARTIFACT_REGISTRY}/${_SERVICE_NAME}:${BRANCH_NAME}'
      - '--destination=${_ARTIFACT_REGISTRY}/${_SERVICE_NAME}:${BRANCH_NAME}-${SHORT_SHA}'
      - '--destination=${_ARTIFACT_REGISTRY}/${_SERVICE_NAME}:latest'
      - '--cache=true'
      - '--cache-ttl=24h'
      - '--build-arg=ENV=$BRANCH_NAME'
      - '--build-arg=BUILD_DATE=$BUILD_ID'
      - '--build-arg=VCS_REF=${COMMIT_SHA}'
      - '--build-arg=VERSION=${BRANCH_NAME}-${SHORT_SHA}'
    waitFor: ['install-and-test']

  # Step 3: Deploy to Cloud Run (Development/Staging)
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'deploy-dev-staging'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Determine environment based on branch
        if [[ "${BRANCH_NAME}" == "main" || "${BRANCH_NAME}" == "master" ]]; then
          ENV="production"
          MIN_INSTANCES="2"
          MAX_INSTANCES="100"
          CPU="4"
          MEMORY="4Gi"
        elif [[ "${BRANCH_NAME}" == "staging" ]]; then
          ENV="staging"
          MIN_INSTANCES="1"
          MAX_INSTANCES="50"
          CPU="2"
          MEMORY="2Gi"
        else
          ENV="development"
          MIN_INSTANCES="0"
          MAX_INSTANCES="10"
          CPU="1"
          MEMORY="1Gi"
        fi
        
        SERVICE_NAME="${_SERVICE_NAME}-${ENV}"
        
        echo "ðŸš€ Deploying to Cloud Run (${ENV} environment)..."
        
        gcloud run deploy ${SERVICE_NAME} \
          --image ${_ARTIFACT_REGISTRY}/${_SERVICE_NAME}:${COMMIT_SHA} \
          --region ${_REGION} \
          --platform managed \
          --allow-unauthenticated \
          --port 8080 \
          --cpu ${CPU} \
          --memory ${MEMORY} \
          --min-instances ${MIN_INSTANCES} \
          --max-instances ${MAX_INSTANCES} \
          --concurrency 1000 \
          --timeout 300 \
          --set-env-vars="NODE_ENV=${ENV}" \
          --set-env-vars="PROJECT_ID=${_PROJECT_ID}" \
          --set-env-vars="REGION=${_REGION}" \
          --set-env-vars="BUILD_ID=${BUILD_ID}" \
          --set-env-vars="COMMIT_SHA=${COMMIT_SHA}" \
          --set-secrets="DATABASE_URL=database-url:latest" \
          --set-secrets="REDIS_URL=redis-url:latest" \
          --set-secrets="JWT_SECRET=jwt-secret:latest" \
          --set-secrets="BLAND_API_KEY=bland-api-key:latest" \
          --labels="environment=${ENV},version=${SHORT_SHA},branch=${BRANCH_NAME},managed-by=cloud-build" \
          --service-account=bland-service-account@${_PROJECT_ID}.iam.gserviceaccount.com \
          --vpc-connector=projects/${_PROJECT_ID}/locations/${_REGION}/connectors/bland-connector \
          --vpc-egress=all-traffic \
          --revision-suffix=${SHORT_SHA}
        
        # Get service URL
        SERVICE_URL=$(gcloud run services describe ${SERVICE_NAME} --region ${_REGION} --format 'value(status.url)')
        echo "âœ… Deployed to: ${SERVICE_URL}"
        
        # Save URL for next steps
        echo ${SERVICE_URL} > /workspace/service_url.txt
    waitFor: ['build-image']

  # Step 4: Run smoke tests
  - name: 'gcr.io/cloud-builders/curl'
    id: 'smoke-tests'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        SERVICE_URL=$(cat /workspace/service_url.txt)
        echo "ðŸ§ª Running smoke tests against ${SERVICE_URL}"
        
        # Health check
        response=$(curl -s -o /dev/null -w "%{http_code}" ${SERVICE_URL}/health || echo "000")
        if [[ $response == "200" ]]; then
          echo "âœ… Health check passed"
        else
          echo "âŒ Health check failed with status: $response"
          exit 1
        fi
        
        # API check (if applicable)
        api_response=$(curl -s -o /dev/null -w "%{http_code}" ${SERVICE_URL}/api/status || echo "000")
        if [[ $api_response == "200" || $api_response == "404" ]]; then
          echo "âœ… API endpoint check passed"
        else
          echo "âš ï¸ API endpoint returned status: $api_response"
        fi
    waitFor: ['deploy-dev-staging']

  # Step 5: Traffic migration (for production only)
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'traffic-migration'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        if [[ "${BRANCH_NAME}" == "main" || "${BRANCH_NAME}" == "master" ]]; then
          echo "ðŸ”„ Performing gradual traffic migration for production..."
          
          SERVICE_NAME="${_SERVICE_NAME}-production"
          
          # Get the new revision name
          NEW_REVISION=$(gcloud run revisions list \
            --service=${SERVICE_NAME} \
            --region=${_REGION} \
            --format="value(name)" \
            --limit=1)
          
          # Get the previous revision name
          OLD_REVISION=$(gcloud run revisions list \
            --service=${SERVICE_NAME} \
            --region=${_REGION} \
            --format="value(name)" \
            --limit=2 | tail -n 1)
          
          if [[ ! -z "${OLD_REVISION}" && "${OLD_REVISION}" != "${NEW_REVISION}" ]]; then
            echo "Migrating traffic gradually..."
            
            # 10% to new revision
            gcloud run services update-traffic ${SERVICE_NAME} \
              --region=${_REGION} \
              --to-revisions=${NEW_REVISION}=10,${OLD_REVISION}=90
            
            sleep 30
            
            # Check metrics (placeholder - implement actual metric checks)
            echo "Checking metrics..."
            
            # 50% to new revision
            gcloud run services update-traffic ${SERVICE_NAME} \
              --region=${_REGION} \
              --to-revisions=${NEW_REVISION}=50,${OLD_REVISION}=50
            
            sleep 30
            
            # 100% to new revision
            gcloud run services update-traffic ${SERVICE_NAME} \
              --region=${_REGION} \
              --to-revisions=${NEW_REVISION}=100
            
            echo "âœ… Traffic migration completed"
          else
            echo "No previous revision found or same revision. Skipping traffic migration."
          fi
        else
          echo "Skipping traffic migration for non-production environment"
        fi
    waitFor: ['smoke-tests']

  # Step 6: Cleanup old images
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'cleanup'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "ðŸ§¹ Cleaning up old images..."
        
        # Keep only the last 10 images for this branch
        IMAGES=$(gcloud artifacts docker images list \
          ${_ARTIFACT_REGISTRY}/${_SERVICE_NAME} \
          --filter="tags:${BRANCH_NAME}" \
          --sort-by=~createTime \
          --format="get(package)" \
          --limit=1000)
        
        # Skip the first 10 and delete the rest
        echo "$IMAGES" | tail -n +11 | while read -r image; do
          if [[ ! -z "$image" ]]; then
            echo "Deleting: $image"
            gcloud artifacts docker images delete "$image" --quiet || true
          fi
        done
        
        echo "âœ… Cleanup completed"
    waitFor: ['traffic-migration']

  # Step 7: Send notification
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'notify'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        SERVICE_URL=$(cat /workspace/service_url.txt)
        
        # Create build summary
        cat > /workspace/build_summary.json <<EOF
        {
          "build_id": "${BUILD_ID}",
          "project_id": "${_PROJECT_ID}",
          "branch": "${BRANCH_NAME}",
          "commit": "${COMMIT_SHA}",
          "short_sha": "${SHORT_SHA}",
          "repo": "${REPO_NAME}",
          "trigger": "${TRIGGER_NAME}",
          "status": "SUCCESS",
          "service_url": "${SERVICE_URL}",
          "build_url": "https://console.cloud.google.com/cloud-build/builds/${BUILD_ID}?project=${_PROJECT_ID}"
        }
        EOF
        
        echo "ðŸ“§ Build completed successfully!"
        echo "Build ID: ${BUILD_ID}"
        echo "Service URL: ${SERVICE_URL}"
        echo "Build logs: https://console.cloud.google.com/cloud-build/builds/${BUILD_ID}?project=${_PROJECT_ID}"
        
        # If you have a notification service, call it here
        # Example: Send to Pub/Sub topic for notifications
        if gcloud pubsub topics describe build-notifications &>/dev/null; then
          gcloud pubsub topics publish build-notifications \
            --message="$(cat /workspace/build_summary.json)"
        fi
    waitFor: ['cleanup']

# Artifacts to be uploaded to Cloud Storage
artifacts:
  objects:
    location: 'gs://${_PROJECT_ID}-build-artifacts/${BUILD_ID}'
    paths:
      - '/workspace/build_summary.json'

# Images to be pushed to Artifact Registry
images:
  - '${_ARTIFACT_REGISTRY}/${_SERVICE_NAME}:${COMMIT_SHA}'
  - '${_ARTIFACT_REGISTRY}/${_SERVICE_NAME}:${BRANCH_NAME}'
  - '${_ARTIFACT_REGISTRY}/${_SERVICE_NAME}:${BRANCH_NAME}-${SHORT_SHA}'
  - '${_ARTIFACT_REGISTRY}/${_SERVICE_NAME}:latest'

# Available secrets (must be configured in Secret Manager)
availableSecrets:
  secretManager:
    - versionName: projects/${_PROJECT_ID}/secrets/bland-api-key/versions/latest
      env: 'BLAND_API_KEY'
    - versionName: projects/${_PROJECT_ID}/secrets/database-url/versions/latest
      env: 'DATABASE_URL'
    - versionName: projects/${_PROJECT_ID}/secrets/jwt-secret/versions/latest
      env: 'JWT_SECRET'
